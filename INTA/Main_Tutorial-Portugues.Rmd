Esse material é uma atualização e tradução dos materiais elaborados pelos alunos do Departamento de Genética da ESALQ/USP - Brasil. Acesse o conteúdo em portugues ministrado em outros eventos [nesse site](https://cristianetaniguti.github.io/Workshop_genetica_esalq/).

Sugerimos que, antes de iniciar a prática aqui descrita, siga [este tutorial](https://cristianetaniguti.github.io/INTA/Installation_Tutorial-Portugues.html) para instalação do R e do RStudio.


# Familiarização com a interface do RStudio

Abrindo o RStudio você verá:

<img src="imagens/Rstudio.png"  style="width:700px;height:500px;">

A interface é separada em quatro janelas com principais funções:

* Edição de código
* Ambiente de trabalho e histórico
* Console
* Arquivos, gráficos, pacotes e ajuda

Explore cada uma das janelas. São inúmeras funcionalidades para cada uma delas, veremos algumas delas no decorrer do curso.

## Um primeiro script

A janela de edição de código (provavelmente localizada no canto superior esquerdo) será utilizada para escrever o seu código. Abra um novo script clicando no `+` no canto superior esquerdo e selecionando `R script`.

Vamos então iniciar os trabalhos com o tradicional `Hello World`. Digite no seu script:

```{r}
cat("Hello world")
```

Agora, selecione a linha e aperte o botão `Run` ou utilize `Ctrl + enter`.

Ao fazer isso o seu código será processado na janela `Console`, onde aparecerá em azul (se você estiver com as cores padrão do R) o código escrito e, logo em seguida, o resultado desejado. A linha somente não será processada no console se houver o símbolo `#` na frente. Agora, experimente colocar `#` na frente do código escrito. Novamente, selecione a linha e aperte `Run`. 

```{r}
# cat("Hello world")
```

O símbolo `#` é utilizado para **comentários** no código. Esta é uma ótima prática de organização e ajuda a lembrar, posteriormente, o que você estava pensando quando escreveu o código. Também é essencial para que outras pessoas possam entendê-lo. Como no exemplo:

```{r}
# Iniciando os trabalhos no R
cat("Hello world")
```

**Importante**: sempre que quiser realizar alguma alteração, edite o seu script e não diretamente no console, pois tudo o que neste é escrito, não terá como ser salvo!

Para salvar seu script, você pode utilizar a aba `Files` localizada (como padrão) no canto direito inferior. Você pode procurar uma localização de sua preferência, criar uma nova pasta com o nome `CursoR`. 

<span style="color:red"> Dica: </span>

* Evite colocar espaços e pontuações no nome das pastas e arquivos, isso pode dificultar o acesso via linha de comando no R. Por exemplo, ao invés de `Curso R`, optamos por `CursoR`.

Depois, basta clicar no disquete localizado no cabeçalho do RStudio ou com `Ctrl + s` e selecionar o diretório `CursoR` criado. Scripts em R são salvos com a extensão `.R`. 

## Estabelecendo diretório de trabalho

Outra boa prática no R é deixar o script no mesmo diretório onde estão seus dados brutos (arquivos de entrada no script) e os dados processados (gráficos, tabelas, etc). Para isso, vamos fazer com que o R identifique o mesmo diretório em que você salvou o script como **diretório de trabalho**. Assim, ele entenderá que é dali que os dados serão obtidos e é para lá que também irão os resultados.

Você pode fazer isso utilizando as facilidades do RStudio, basta localizar o diretório `CursoR` pela aba `Files`, clicar em `More` e depois "Set as Working Directory". Repare que irá aparecer no console algo como:

```{r, eval=FALSE}
setwd("~/Documents/CursoR")
```

Ou seja, você pode utilizar este mesmo comando para realizar esta ação. O resultado será nossa pasta de trabalho. Quando estiver perdido/a ou para ter certeza que o diretório de trabalho foi alterado utilize:

```{r, eval=FALSE}
getwd()
```

## Facilitando a vida com `Tab`

Agora, imagine que você tem um diretório como `~/Documentos/mestrado/semestre1/disciplina_tal/aula_tal/dados_28174/analise_276182/resultados_161/`. Não é fácil lembrar todo este caminho para escrever num comando `setwd()`.

Além da facilidade da janela do RStudio, você também pode utilizar a tecla `Tab` para completar o caminho para você. Experimente buscando alguma pasta no seu computador. Basta começar a digitar o caminho e apertar `Tab`, ele irá completar o nome para você! Se você tiver mais do que um arquivo com aquele início de nome, aperte duas vezes o `Tab`, ele mostrará todas as opções.

O `Tab` funciona não só para indicar caminhos, mas também para comandos e nomes de objetos. É muito comum cometermos erros de digitação no código. Utilizar o `Tab` reduzirá significativamente esses erros.

O `Tab` pode ser ainda mais poderoso se você tiver acesso à ferramenta [GitHub Copilot](https://docs.posit.co/ide/user/ide/guide/tools/copilot.html). Com ela, você pode utilizar o `Tab` para completar o código que você está escrevendo. É uma ferramenta baseada em inteligência artificial que sugere o código que você está escrevendo. É uma ferramenta paga, mas você pode utilizar gratuitamente por 60 dias.

# Operações básicas

Vamos então à linguagem! 

O R pode funcionar como uma simples **calculadora**, que utiliza a mesma sintaxe que outros programas (como o excel):

```{r, eval=FALSE}
1+1.3                 #Decimal definido com "."
2*3
2^3
4/2

sqrt(4)              #raíz quadrada
log(100, base = 10)  #Logaritmo na base 10
log(100)             #Logaritmo com base neperiana

```

Agora, utilize as operações básicas para solucionar expressão abaixo. Lembre-se de utilizar parênteses `()` para estabelecer prioridades nas operações.

$(\frac{13+2+1.5}{3})+ log_{4}96$

Resultado esperado:

```{r, echo=FALSE}
((13+2+1.5)/3) + log(96, base = 4)
```

Repare que, se posicionar o parênteses de forma incorreta, o código não resultará em nenhuma mensagem de erro, pois este é um erro que chamamos de **erro lógico** ou **erro silencioso**, ou seja, o código roda, mas não faz o que você gostaria que ele fizesse. Esse é o tipo de erro mais perigoso e difícil de ser consertado. Veja um exemplo:

```{r}
13+2+1.5/3 + log(96, base = 4)
```

Os erros que produzem uma mensagem, seja um aviso (**warning**) ou um erro (**error**) são chamados de **erros de sintaxe**. Nesses casos, o R retornará uma mensagem para te ajudar a corrigí-los. Os **warnings** não comprometem o funcionamento do código, mas chamam a atenção para algum ponto; já os **errors** precisam necessariamente ser corrigidos para que o código rode.

Exemplo de error:

```{r, eval=FALSE}
((13+2+1,5)/3) + log(96, base = 4)
```

Você pode também esquecer de fechar algum parênteses, ou aspas, ou colchetes, ou chaves, nesses casos, o R ficará aguardando o comando para fechar o bloco de código sinalizando com um `+`:

```{r, eval=FALSE}
((13+2+1.5)/3 + log(96, base = 4)
```

Se acontecer, vá até o console e aperte ESC, que o bloco será finalizado para que você possa corrigí-lo.

Os comandos `log` e `sqrt` são duas de muitas outras funções básicas que o R possui. Funções são conjuntos de instruções organizadas para realizar uma tarefa. Para todas elas, o R possui uma descrição para auxiliar no seu uso. Para acessar essa ajuda use:

```{r, eval=FALSE}
?log
```

E será aberta a descrição da função na janela `Help` do RStudio.

Se a descrição do próprio R não for suficiente para você entender como funciona a função, busque no google (de preferência em inglês). Existem diversos sites e fóruns com informações didáticas das funções do R.

## Operações com vetores

Os vetores são as estruturas mais simples trabalhadas no R. Construímos um vetor com uma sequencia numérica usando:

```{r}
c(1,3,2,5,2)
```

**MUITA ATENÇÃO**: O *c* é a função do R (*Combine Values into a Vector or List*) com a qual construímos um vetor! 

Utilizamos o simbolo `:` para criar sequências de números inteiros, como:

```{r}
1:10
```

Podemos utilizar outras funções para gerar sequências, como:

```{r}
seq(from=0, to=100, by=5)
# ou
seq(0,100,5) # Se você já souber a ordem dos argumentos da função
```

* Crie uma sequencia utilizando a função `seq` que varie de 4 a 30, com intervalos de 3 em 3.

```{r, echo=FALSE}
seq(from=4, to=30, by=3)
```

A função `rep` gera sequências com números repetidos:

```{r}
rep(3:5, 2)
```

Podemos realizar operações utilizando esses vetores:

```{r,eval=FALSE}
c(1,4,3,2)*2
c(4,2,1,5)+c(5,2,6,1)
c(4,2,1,5)*c(5,2,6,1)
```

Repare que já esta ficando cansativo digitar os mesmos números repetidamente, vamos resolver isso criando **objetos** para armazenar nossos vetores e muito mais. 

# Criando objetos

O armazenamento de informações em objetos e a possível manipulação desses faz do R uma linguagem *orientada por objetos*. Para criar um objeto basta atribuir valores para as variáveis, como a seguir:

```{r, results='hide'}
x = c(30.1,30.4,40,30.2,30.6,40.1)
# ou
x <- c(30.1,30.4,40,30.2,30.6,40.1)

y = c(0.26,0.3,0.36,0.24,0.27,0.35)
```

Os mais antigos costumam usar o sinal `<-`, mas tem a mesma função de `=`. Há quem prefira usar o `<-` como atribuição em objetos e `=` apenas para definir os argumentos dentro de funções. Organize-se da forma como preferir.

Para acessar os valores dentro do objeto basta:

```{r}
x
```

A linguagem é sensível à letras maiúsculas e minúsculas. Logo, `x` é diferente de `X`:

```{r, eval=FALSE}
X
```

O objeto `X` não foi criado. 

O nome dos objetos é uma escolha pessoal, a sugestão é tentar manter um padrão para melhor organização. Aqui estão alguma dicas:

* Usar nomes descritivos
* Evitar começar com números
* Não usar espaços (usar _ ou camelCase)
* Não usar caracteres especiais
* Manter consistência no padrão escolhido
* Evitar nomes muito longos
* Não usar acentos ou caracteres não-ASCII

Alguns nomes não podem ser usados por estabelecerem papéis fixos no R, são eles:

* TRUE - Verdadeiro, valor lógico
* FALSE - Falso, valor lógico
* if, else, for, while, break, next - Palavras reservadas para estruturas condicionais e de repetição
* for, while, repeat - Palavras reservadas para estruturas de repetição
* function - Palavra reservada para definição de funções
* in, NA, NaN, NULL - Palavras reservadas para valores especiais
* NA_integer__, NA_real_, NA_character_, NA_complex_ - Valores especiais para representar dados ausentes

Podemos então realizar as operações com o objeto criado:

```{r}
x+2
x*2
```

Para realizar a operação o R alinha os dois vetores e realiza a operação elemento à elemento. Observe:

```{r}
x + y
x*y
```

Se os vetores tiverem tamanhos diferentes, ele irá repetir o menor para realizar a operação elemento a elemento com todos do maior.

```{r, results='hide'}
x*2
x*c(1,2)
```

Se caso o menor vetor não for múltiplo do maior, obteremos um aviso:

```{r}
x*c(1,2,3,4)
```

Repare que o **warning** não compromente o funcionamento do código, ele só dá uma dica de que algo pode não estar da forma como você gostaria.

Podemos também armazenar a operação em outro objeto:

```{r, results='hide'}
z <- (x+y)/2
z
```

Podemos também aplicar algumas funções, como exemplo:

```{r}
sum(z)  # soma dos valores de z
mean(z) # média 
var(z)  # variância
```

## Indexação

Acessamos somente o 3º valor do vetor criado com `[]`:

```{r, results='hide'}
z[3]
```

Também podemos acessar o número da posição 2 a 4 com:

```{r}
z[2:4]
```

Para obter informações do vetor criado utilize:

```{r}
str(z)
```

A função `str` nos diz sobre a estrutura do vetor, que se trata de um vetor **numérico** com 6 elementos. 

Os vetores também podem receber outras categorias como **caracteres**:

```{r}
clone <- c("GRA02", "URO01", "URO03", "GRA02", "GRA01", "URO01")
```

Outra classe são os **fatores**, esses podem ser um pouco complexos de lidar.

De forma geral, fatores são valores categorizados por `levels`, como exemplo, se transformarmos nosso vetor de caracteres `clone` em fator, serão atribuidos níveis para cada uma das palavras:

```{r}
clone_fator <- as.factor(clone)
str(clone_fator)
levels(clone_fator)
```

Dessa forma, teremos apenas 4 níveis para um vetor com 6 elementos, já que as palavras "GRA02" e "URO01" se repetem. Podemos obter o número de elementos do vetor ou o seu comprimento com:

```{r}
length(clone_fator)
```

Também há vetores **lógicos**, que recebem valores de verdadeiro ou falso:

```{r}
logico <- x > 40
logico   # Os elementos são maiores que 40?
```

Com ele podemos, por exemplo, identificar quais são as posições dos elementos maiores que 40:

```{r}
which(logico)  # Obtendo as posiçoes dos elementos TRUE

x[which(logico)] # Obtendo os números maiores que 40 do vetor x pela posição
# ou
x[which(x > 40)]
```

Também podemos localizar elementos específicos com:

```{r}
clone %in% c("URO03", "GRA02")
```

Também podem ser úteis as funções `any` e `all`. Pesquise sobre elas.

Encontre mais sobre outros operadores lógicos, como o `>` utilizado, neste [link](http://www.statmethods.net/management/operators.html).

**Warning1**

Faça uma sequência numérica, contendo 10 valores inteiros, e salve em um objeto chamado "a".

```{r}
(a <- 1:10)
```

Crie outra sequência, utilizando números decimais e qualquer operação matemática, de tal forma que seus valores sejam idênticos ao objeto "a".

```{r}
b <- seq(from = 0.1, to = 1, 0.1)
(b <- b*10)
```

Os dois vetores parecem iguais, não?

Então, utilizando um operador lógico, vamos verificar o objeto "b" é igual ao objeto "a".

```{r}
a==b
```

Alguns valores não são iguais. Como isso é possivel?

```{r}
a==round(b)
```

**Warning2**

Não é possível misturar diferentes classes dentro de um mesmo vetor. Ao tentar fazer isso, repare que o R irá tentar igualar para uma única classe:

```{r}
errado <- c(TRUE, "vish", 1)
errado
```

No caso, todos os elementos foram transformados em caracteres.

**Algumas Dicas**: 

* Cuidado com a prioridade das operações, na dúvida, sempre acrescente parenteses conforme seu interesse de prioridade.
* Lembre-se que, se esquecer de fechar algum `(` ou `[` ou `"`, o console do R ficará esperando você fechar indicando um `+`. Nada será processado até que você digite diretamente no console um `)` ou aperte ESC.
* Cuidado para não sobrepor objetos já criados criando outros com o mesmo nome. Use, por exemplo: altura1, altura2.
* Mantenha no seu script .R somente os comandos que funcionaram e, de preferência, adicione comentários. Você pode, por exemplo, comentar dificuldades encontradas, para que você não cometa os mesmos erros mais tarde.

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 1**](exercises-Portugues.html#sessao1), se não, faça-os em outro momento e nos envie dúvidas.

## Matrizes

As matrizes são outra classe de objetos muito utilizadas no R, com elas podemos realizar operações de maior escala de forma automatizada.

Por serem usadas em operações, normalmente armazenamos nelas elementos numéricos. Para criar uma matriz, determinamos uma sequência de números e indicamos o número de linhas e colunas da matriz:

```{r}
X <- matrix(1:12, nrow = 6, ncol = 2)
X
```

Podemos também utilizar sequências já armazenadas em vetores para gerar uma matriz, desde que eles sejam numéricos:

```{r}
W <- matrix(c(x,y), nrow = 6, ncol =2)
W
```

Com elas podemos realizar operações matriciais:

```{r}
X*2
X*X        
X%*%t(X)          # Multiplicação matricial
```

Utilizar essas operações exige conhecimento de álgebra de matrizes, se quiser se aprofundar a respeito, o livro *Linear Models in Statistics, Rencher (2008)* possui um boa revisão à respeito. Você também pode explorar a sintaxe do R para essas operações neste [link](http://www.statmethods.net/advstats/matrix.html).

Acessamos os números internos à matriz dando as coordenadas [linha,coluna], como no exemplo:

```{r}
W[4,2] # Número posicionado na linha 4 e coluna 2
```

As vezes pode ser informativo dar nomes às colunas e às linhas da matriz, fazemos isso com:

```{r}
colnames(W) <- c("altura", "diametro")
rownames(W) <- clone
W
```

Essas funções `colnames` e `rownames` também funcionam nos data.frames.

## Data.frames

Diferente das matrizes, não realizamos operações com os data.frames, mas eles permitem a união de vetores com classes diferentes. Os *data frames* são semelhantes a tabelas geradas em outros programas, como o excel.

Os *data frames* são combinações de vetores de mesmo comprimento. Todos os que criamos até agora tem tamanho 6, verifique. 

Podemos assim combiná-los em colunas de um único data.frame:

```{r}
campo1 <- data.frame("clone" = clone,     # Antes do sinal de "="  
                     "altura" = x,        # estabelecemos os nomes  
                     "diametro" = y,      # das colunas
                     "idade" = rep(3:5, 2),
                     "corte"= logico) 
campo1
```

Podemos acessar cada uma das colunas com:

```{r}
campo1$idade
```

Ou também com:

```{r}
campo1[,4] 
```

Aqui, o número dentro dos colchetes se refere à coluna, por ser o segundo elemento (separado por vírgula). O primeiro elemento se refere à linha. Como deixamos o primeiro elemento vazio, estaremos nos referindo a todas as linhas para aquela coluna.

Dessa forma, se quisermos obter um conteúdo específico podemos dar as coordenadas com [linha,coluna]:

```{r}
campo1[1,2] 
```


* Obtenha o diâmetro do clone "URO03".


```{r, echo=FALSE}
campo1[3,3] 
```

Mesmo se tratando de um *data frame*, podemos realizar operações com os vetores numéricos que a compõe.

* Com o diâmetro e a altura das árvores, calcule o volume conforme a fórmula a seguir e armazene em um objeto `volume`:

$3.14*(diametro/2)^2*altura$

```{r, echo=FALSE}
volume <- 3.14*((campo1$diametro/2)^2)*campo1$altura
volume
```

Agora, vamos adicionar o vetor calculado com o volume ao nosso *data frame*. Para isso use a função `cbind`.

```{r}
campo1 <- cbind(campo1, volume)
campo1
str(campo1)
```

**Algumas dicas**:

* Lembre-se que, para construir matrizes e *data frames*, as colunas devem apresentar o mesmo número de elementos.

* Caso não saiba o operador ou a função que deve ser utilizada, busque no google ou pergunte para o chatgpt ou qualquer outra ferramenta. Por exemplo, se está em dúvida em como calcular o desvio padrão, busque por "desvio padrão R" ou, melhor ainda, "standard deviation R". A comunidade do R é bastante ativa e grande parte das suas perguntas sobre ele já foram respondidas em algum lugar da web.

* Não esqueça que tudo o que fizer no R precisa ser explicitamente indicado, como uma multiplicação 4ac com `4*a*c`. Para gerar um vetor 1,3,2,6 é necessário: `c(1,3,2,6)`.

## Listas

Listas consistem em uma coleção de objetos, não necessariamente de mesma classe. Nelas podemos armazenar todos os outros objetos já vistos e recuperá-los pela indexação com `[[`. Como exemplo, vamos utilizar alguns objetos que já foram gerados.

```{r}
minha_lista <- list(campo1 = campo1, media_alt = tapply(campo1$altura, campo1$idade, mean), matrix_ex = W)
str(minha_lista)
```

Quero acessar o data.frame `campo1`

```{r}
minha_lista[[1]] 
# ou
minha_lista$campo1
```

Para acessar uma coluna específica no data.frame `campo1`, que está dentro da minha_lista:  

```{r}
minha_lista[[1]][[3]]
# ou
minha_lista[[1]]$diametro
# ou
minha_lista$campo1$diametro
```

Listas são muito úteis, por exemplo, quando vamos utilizar/gerar diversos objetos dentro de um loop. 

## Arrays

Este é um tipo de objeto que você provavelmente não irá utilizar agora no início, mas é bom saber da sua existência. São utilizados para armazenar dados com mais de duas dimensões. Por exemplo, se criarmos um array:

```{r}
(meu_array <- array(1:24, dim = c(2,3,4)))
```

Teremos quatro matrizes com duas linhas e três colunas e os números de 1 a 24 estarão distribuídos nelas por colunas.

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 2**](exercises-Portugues.html#sessao2), se não, faça-os em outro momento e nos envie dúvidas pelo fórum.


# Importando e exportando dados

Os arquivos RData são exclusivos do R, clicando duas vezes no arquivo ou utilizando:

```{r}
load("data/dia_1.RData")
```

Você vai recuperar todos os objetos gerados até agora no tutorial. Para gerar esse arquivo RData, eu rodei todos os códigos daqui para cima e usei:

```{r, eval=FALSE}
save.image(file = "dia_1.RData")
```

Este comando salva tudo o que você tem no seu Ambiente Global (todos os objetos que aparecem ali no canto direito superior). Você pode também salvar somente um objeto com:

```{r, eval=FALSE}
save(campo1, file = "campo1.RData")
```

Se removermos ele do nosso Ambiente Global com:

```{r, eval=FALSE}
rm(campo1)  # Certifique-se que salvou o arquivo RData antes de removê-lo
```

Podemos facilmente obtê-lo novamente com:

```{r, eval=FALSE}
load("campo1.RData")
```

O formato RData é exclusivo para o R, ele é interessante de ser usado para fazer o que estamos fazendo, paramos a análise em um dia, vamos continuar em um outro e não queremos ter que rodar tudo de novo. Mas muitas vezes precisamos exportar nossos dados para outros programas, que exigem outros formatos, como, por exemplo, `.txt` ou `.csv`. Para isso utilizamos:

```{r, eval=FALSE}
write.table(campo1, file = "campo1.txt", sep = ";", dec = ".", row.names = FALSE)
write.csv(campo1, file = "campo1.csv", row.names = TRUE)
```

Obs: Você pode adquirir pacotes para exportar e importar dados com outros fomatos, como exemplo o pacote `xlsx` exporta e importa dados com formato do excel. O pacote `vroom` pode ser utilizado para compactar grandes tabelas. Para instalar pacotes, utilize a função `install.packages("nome_do_pacote")` e para carregar o pacote utilize `library(nome_do_pacote)`.Veremos mais sobre pacotes na sessão "Aplicação de Pacotes" deste curso.

Ao exportar, há diversas opções para a formatação do arquivo, é importante considerá-las se o arquivo for usado em outro sofware posteriormente.

Abra os arquivos gerados no seu bloco de notas para visualizar sua formatação. Repare que o arquivo `.txt` foi salvo com o separador `;` e o separador decimal `.`. Já o arquivo `.csv` foi salvo com o separador de vírgula `,` e o separador decimal `.`.

Esses arquivos podem ser lidos novamente pelo R, utilizando as funções e suas especificações:

```{r, eval=FALSE}
campo1_txt <- read.table(file = "campo1.txt", sep=";", dec=".", header = TRUE)
campo1_csv <- read.csv(file = "campo1.csv")
head(campo1_txt)
head(campo1_csv)
```

Agora que aprendemos a importar dados, vamos trabalhar com o conjunto gerado a partir dos participantes da disciplina Biometria de Marcadores (ESALQ/USP - Brasil) - Turma de 2021. 

<span style="color:red">
A planilha com os dados está disponível no link abaixo, adicione-a ao seu diretório de trabalho ou indique o caminho da pasta ao importá-la para dentro do R, como a seguir. </span> 

* [dados.RData](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/dados_alunos2021.RData) 
* [dados.csv](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/dados_alunos2021.csv)

Também podemos importar os dados diretamente do github, apontando o endereço web.

```{r, eval=FALSE}
dados <- read.csv("https://github.com/Cristianetaniguti/Workshop_genetica_esalq/raw/master/SIFSC11/dados_alunos2021.csv")

```

Aqui usaremos também o argumento `na.strings` que irá indicar como foram nomeados os dados perdidos.

```{r, eval=FALSE}
dados <- read.csv(file = "data/dados_alunos2021.csv", na.strings="-", header = T, dec = ",")
head(dados)
```

```{r}
load("data/dados_alunos2021.RData")
```

Vamos explorar a estrutura dos dados coletados:

```{r}
str(dados)
# também
dim(dados)
```

Repare que nos nomes das colunas ainda estão as perguntas completas feitas no formulário, vamos alterar para nomes mais fáceis de trabalhar:

```{r}
colnames(dados)

colnames(dados) = c("Ocupacao", "Graduacao", "Conhecimentos_Genetica", "Conhecimentos_Estatistica", "Conhecimento_Gen_Est", 
                   "Latitude", "Longitude")
colnames(dados)
str(dados)
```

# Manipulando os dados

Agora usaremos os dados que temos para aprender diferentes comandos e funções do Ambiente R.

Primeiro, vamos verificar quantos alunos responderam as questões do formulario da disciplina, contando o número de linhas, para isso use a função `nrow`.

```{r}
nrow(dados)
```

Vamos então verificar se temos no nosso grupo pessoas que compartilham a mesma graduação e ocupação.

Podemos verificar isso facilmente com a função `table`, que indica a frequência de cada observação:
 
```{r, eval=FALSE}
table(dados$Graduacao)
table(dados$Ocupacao)
```

# Estruturas condicionais

## if e else

Para nossa próxima atividade com os dados, vamos primeiro entender como funcionam as estruturas `if` e `else`.

Nas funções condicionais `if` e `else`, estabelecemos uma condição para if, se ela for verdade a atividade será realizada, caso contrário (else) outra tarefa será. Como no exemplo:

```{r}
if(2 >3){
  cat("dois é maior que três")
} else {
  cat("dois não é maior que três")
}
```

* Descubra a Nivel de Conhecimentos em Genetica (3ª coluna) da segunda pessoa que o respondeu (linha 2). Envie uma mensagem motivacional se ela possuir conhecimentos basicos, outra se a pessoa ja possuir conhecimento Intermediario ou Avançado (restante das respostas). (dica: o sinal `==` se refere a "exatamente igual a")

```{r}
if(dados[2,3] =="Básico"){
  cat("Força, Mendel acredita em você!")
} else {
  cat("Mendel agradece a preferência")
}
```

Podemos espeficiar mais do que uma condição repetindo a estrutura `if` `else`:
Agora vamos estudar a ocupação das pessoas que responderam ao questionário.

```{r}
if(dados[2,1] == "Mestrado"){
  cat("Força, o quinto dia útil esta chegando!")
} else if (dados[2,1] == "Doutorado"){
  cat("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
} else {
  cat("Esse já tem a carteira assinada, que beleza!")
}
```

Mas repare que só é possível utilizar essas estruturas para um elemento individual do vetor ou em todo ele, se quisermos percorrer os elementos individualmente precisamos recorrer a outro recurso.

# Estruturas de repetição

## For

Esse recurso pode ser a função `for`, uma função muito utilizada e poderosa. Ela constitui uma estrutura de loop, pois irá aplicar a mesma atividade repetidamente até atingir uma determinada condição. Veja exemplos:

```{r}
for(i in 1:10){
  print(i)
}

test <- vector()
for(i in 1:10){
  test[i] <- i+4 
}
test
```

Nos casos acima, `i` funciona como um índice que irá variar de 1 até 10 a operação determinada entre chaves.

Com essa estrutura, podemos repetir a operação realizada com as estruturas `if` e `else` para todo o vetor:

```{r, eval=F}
for(i in 1:nrow(dados)){
  if(dados[i,1] == "Mestrado"){
    print("Força, o quinto dia útil esta chegando!")
  } else if (dados[i,1] == "Doutorado"){
    print("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
  } else {
    print("Esse já tem a carteira assinada, que beleza!")
  }
}
```

**Dica: Identação**

Repare a diferença:

```{r, eval=FALSE}
# Sem identação
for(i in 1:nrow(dados)){
if(dados[i,1] == "Mestrado"){
print("Força, o quinto dia útil esta chegando!")
} else if (dados[i,1] == "Doutorado"){
print("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
} else {
print("Esse já tem a carteira assinada, que beleza!")
}
}

# Com identação correta
for(i in 1:nrow(dados)){
  if(dados[i,1] == "Mestrado"){
    print("Força, o quinto dia útil esta chegando!")
  } else if (dados[i,1] == "Doutorado"){
    print("Assim como seus amigos do mestrado, acredite até sexta a bolsa cai!")
  } else {
    print("Esse já tem a carteira assinada, que beleza!")
  }
}
```

O editor de código do RStudio tem uma facilitação para identar códigos em R, selecione a área que deseja identar e aperte `Ctrl+i`.

Agora vamos trabalhar com a coluna 2, que possui a informação da graduação dos participantes. Repare que a função `table` retorna diferentes categorias que poderiam ser resumidas em apenas uma, como  "Engenharia agronômica" e "Agronomia". Vamos utilizar um loop para descobrir quais responderam áreas relacionadas à "Agro". Depois, quais dessas respostas não foram "Agronomia" e pedir para que este participante modifique a resposta digitando apenas "Agronomia". 

Dica 1: Para identificar o padrão "Agro" podemos utilizar  a função `grepl`.
Dica 2: Podemos utilizar if dentro de if

```{r}
# Exemplo do uso da função grepl
dados[,2]
grepl("Agro", dados[,2]) # Quais linhas contém os caracteres "Agro"
dados[grepl("Agro", dados[,2]),2]

for(i in 1:nrow(dados)){
  if(grepl("Agro", dados[i,2])){
    if(dados[i,2] != "Agronomia"){
     print("Por favor, substitua sua resposta por Agronomia.") 
    }
  } 
}
```

Para que seja possível imprimir conteúdo de objetos durante o loop, usamos a função `cat`, ela não separa cada resposta em uma linha, precisamos colocar o `\n` indicando a quebra de linha.

Agora vamos nos mesmos homogeneizar essas informações. Podemos armazenar em uma variável a posição das linhas identificadas, então corrigiremos manualmente somente essas:

```{r}
homog <- vector()
for(i in 1:nrow(dados)){
  if(grepl("Agro", dados[i,2])){
    if(dados[i,2] != "Agronomia"){
     print("Por favor, substitua sua resposta por Agronomia.") 
     homog <- c(homog, i)
    }
  } 
}

homog
```

> Como você faria para corrigir esses elementos errados? Tente!

['dados[homog, 2] <- "Agronomia"']{.spoiler}

## While

Nesse tipo de estrutura de repetição a tarefa será realizada até que seja atingida determinada condição.

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  cat(x)
}
```

É muito importante que nessa estrutura a condição seja atingida, caso contrário o loop irá funcionar infinitamente e você terá que interrompê-lo por meios externos. Um exemplo desses "meios externos" no RStudio é clicar no simbolo em vermelho no canto direito superior da janela do console. Você também pode apertar Ctrl+C no console.

Não é muito difícil disso acontecer, basta um pequeno erro como:

```{r, eval=FALSE}
x <- 1

while(x < 5){
  x + 1
  cat(x)
}
```

Aqui podemos utilizar os comandos `break` e `next` para atender a outras condições, como:

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) break
  cat(x)
}

x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) next
  cat(x)
}

```

## Repeat

Esta estrutura também exige uma condição de parada, mas esta condição é necessariamente colocada dentro do bloco de código com o uso do `break`. Ela então repete o bloco de código até a condição o interrompa.

```{r}
x <- 1
repeat{
  x <- x+1
  cat(x)
  if(x==4) break
}

```

## Loops dentro de loops

É possível também utilizarmos estruturas de repetição dentro de estruturas de repetição. Por exemplo, se quisermos trabalhar tanto nas colunas como nas linhas de uma matrix.

```{r}
# Criando uma matrix vazia
ex_mat <- matrix(nrow=10, ncol=10)

# cada número dentro da matrix será o produto no índice da coluna pelo índice da linha
for(i in 1:dim(ex_mat)[1]) {
  for(j in 1:dim(ex_mat)[2]) {
    ex_mat[i,j] = i*j
  }
}

```

Outro exemplo de uso:

```{r}
var1 <- c("fertilizante1", "fertilizante2")
var2 <- c("ESS", "URO", "GRA")

w <- 1
for(i in var1){
  for(j in var2){
    nome_arquivo <- paste0(i,"_planta_",j,".txt")
    arquivo <- data.frame("bloco" = "fake_data", "tratamento" ="fake_data")
    write.table(arquivo, file = nome_arquivo)
    w <- w + 1
  }
}

# Verifique seu diretorio de trabalho, arquivos devem ter sido gerados
```

> Se estiver adiantada/o em relação aos colegas, você já pode fazer os exercícios da [**Sessão 3**](exercicios.html#sessao3), se não, faça-os em outro momento e nos envie dúvidas pelo fórum.

**Algumas dicas**:

* Cuidado ao rodar o mesmo comando mais de uma vez, algumas variáveis podem não ser mais como eram antes. Para que o comando funcione da mesma forma é necessário que os objetos de entrada estejam da forma como você espera.
* Lembrem-se que `=` é para definir objetos e `==` é o sinal de igualdade. 
* Nas estruturas condicionais e de repetição, lembrem-se que é necessário manter a sintaxe esperada: If(){} e for(i in 1:10){}. No *for*, podemos trocar a letra que será o índice, mas é sempre necessário fornecer uma sequência de inteiros ou caracteres.
* Usar identação ajuda a visualizar o começo e fim de cada estrutura de código e facilita o abrir e fechar de chaves. Identação são aqueles espaços que usamos antes da linha, como:

```{r}
# Criando uma matrix vazia
ex_mat <- matrix(nrow=10, ncol=10)

# cada número dentro da matrix será o produto no índice da coluna pelo índice da linha
for(i in 1:dim(ex_mat)[1]) {   # Primeiro nível, não tem espaço
  for(j in 1:dim(ex_mat)[2]) { # Segundo nível tem um espaço (tab)
    ex_mat[i,j] = i*j          # Terceiro nível tem dois espaços
  }                            # Fechei o segundo nível
}                              # Fechei o primeiro nível

```

# Vetorização

Embora loops sejam intuitivos e mais fáceis de entender, eles são mais lentos e menos eficientes do que a vetorização. A vetorização é uma técnica que permite aplicar operações em todos os elementos de um vetor ou matriz de uma só vez, sem a necessidade de iterar sobre cada elemento individualmente.

Aqui esta um simples exemplo de um codigo não vetorizado (utilizando loop) e sua versão vetorizada:

```{r}
# Não vetorizado (usando loop)
numeros <- 1:5
resultado_loop <- numeric(length(numeros))
for(i in 1:length(numeros)) {
    resultado_loop[i] <- numeros[i] * 2
}

# Abordagem vetorizada
numeros <- 1:5
resultado_vetorizado <- numeros * 2

resultado_loop == resultado_vetorizado
```

> Essa transformação de código pode se tornar mais complexa dependendo do cenário. Por exemplo, pense como seria uma versão vetorizada do loop anterior:

```{r}
# Não vetorizado (usando loop)
ex_mat <- matrix(nrow=10, ncol=10)

for(i in 1:dim(ex_mat)[1]) {   
  for(j in 1:dim(ex_mat)[2]) { 
    ex_mat[i,j] = i*j          
  }                            
}

# Vetorizado?
```

Aqui é um bom momento para você praticar a utilizar de uma ferramenta AI para te ajudar a transformar o código em uma versão vetorizada. Você pode utilizar o chatgpt ou o copilot, por exemplo. Compare o resultado do código fornecido com o que você gerou com o loop para verificar se a ferramenta está realmente fazendo o que você deseja. Essa transformação vale a pena se o código em loop estiver muito demorado ou se você tiver que rodar o mesmo código muitas vezes.

['ex_mat <- outer(1:10, 1:10, "*")']{.spoiler}

