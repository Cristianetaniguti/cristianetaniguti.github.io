This material is an update and translation of materials developed by students from the Department of Genetics at ESALQ/USP - Brazil. Access the Portuguese content taught in other events at [this website](https://cristianetaniguti.github.io/Workshop_genetica_esalq/).

We suggest that, before starting the practice described here, follow [this tutorial](https://cristianetaniguti.github.io/INTA/Installation_Tutorial-Portugues.html) for installing R and RStudio.

# Getting Familiar with the RStudio Interface

When opening RStudio, you will see:

<img src="imagens/Rstudio.png"  style="width:700px;height:500px;">

The interface is divided into four windows with main functions:

* Code editing
* Workspace and history
* Console
* Files, plots, packages, and help

Explore each of the windows. There are numerous functionalities for each of them, and we will cover some of them throughout the course.

## A First Script

The code editing window (probably located in the top left corner) will be used to write your code. Open a new script by clicking the `+` in the top left corner and selecting `R script`.

Let's begin our work with the traditional `Hello World`. Type in your script:

```{r}
cat("Hello world")
```

Now, select the line and press the `Run` button or use `Ctrl + enter`.

When you do this, your code will be processed in the `Console` window, where the written code will appear in blue (if you have R's default colors), followed by the desired result. The line will only not be processed in the console if there is a `#` symbol in front of it. Now, try putting `#` in front of the written code. Again, select the line and press `Run`.

```{r}
# cat("Hello world")
```

The `#` symbol is used for **comments** in the code. This is a great organizational practice and helps to remember, later, what you were thinking when you wrote the code. It's also essential for others to understand it. As in the example:

```{r}
# Starting work in R
cat("Hello world")
```

**Important**: whenever you want to make any changes, edit your script and not directly in the console, because everything written in the console cannot be saved!

To save your script, you can use the `Files` tab located (by default) in the bottom right corner. You can look for a location of your preference, create a new folder named `CourseR`.

<span style="color:red"> Tip: </span>

* Avoid putting spaces and punctuation in folder and file names, this can make access via command line in R difficult. For example, instead of `Course R`, we opt for `CourseR`.

Then, just click on the floppy disk icon located in the RStudio header or use `Ctrl + s` and select the created `CourseR` directory. R scripts are saved with the `.R` extension.

## Setting the Working Directory

Another good practice in R is to keep the script in the same directory where your raw data (input files for the script) and processed data (graphs, tables, etc.) are located. For this, we'll have R identify the same directory where you saved the script as the **working directory**. This way, it will understand that this is where the data will be obtained from and where the results will also go.

You can do this using RStudio's facilities, simply locate the `CourseR` directory through the `Files` tab, click on `More` and then "Set as Working Directory". Notice that something like this will appear in the console:

```{r, eval=FALSE}
setwd("~/Documents/CourseR")
```

In other words, you can use this same command to perform this action. The result will be our working folder. When you're lost or to make sure the working directory has been changed, use:

```{r, eval=FALSE}
getwd()
```

## Making Life Easier with `Tab`

Now, imagine you have a directory like `~/Documents/masters/semester1/course_such/class_such/data_28174/analysis_276182/results_161/`. It's not easy to remember this entire path to write in a `setwd()` command.

In addition to the convenience of the RStudio window, you can also use the `Tab` key to complete the path for you. Try it by searching for a folder on your computer. Just start typing the path and press `Tab`, it will complete the name for you! If you have more than one file with that name beginning, press `Tab` twice, it will show you all the options.

The `Tab` key works not only for indicating paths but also for commands and object names. It's very common to make typing errors in code. Using `Tab` will significantly reduce these errors.

`Tab` can be even more powerful if you have access to the [GitHub Copilot](https://docs.posit.co/ide/user/ide/guide/tools/copilot.html) tool. With it, you can use `Tab` to complete the code you're writing. It's an artificial intelligence-based tool that suggests code as you write. It's a paid tool, but you can use it for free for 60 days.

# Basic Operations

Let's get to the language!

R can function as a simple **calculator**, using the same syntax as other programs (like Excel):

```{r, eval=FALSE}
1+1.3                 #Decimal defined with "."
2*3
2^3
4/2

sqrt(4)              #square root
log(100, base = 10)  #Logarithm base 10
log(100)             #Natural logarithm
```

Now, use the basic operations to solve the expression below. Remember to use parentheses `()` to establish priorities in operations.

$(\frac{13+2+1.5}{3})+ log_{4}96$

Expected result:

```{r, echo=FALSE}
((13+2+1.5)/3) + log(96, base = 4)
```

Notice that if you position the parentheses incorrectly, the code won't result in any error message, as this is what we call a **logical error** or **silent error**, meaning the code runs but doesn't do what you want it to do. This is the most dangerous and difficult type of error to fix. See an example:

```{r}
13+2+1.5/3 + log(96, base = 4)
```

Errors that produce a message, whether a **warning** or an **error**, are called **syntax errors**. In these cases, R will return a message to help you correct them. **Warnings** don't compromise the code's functionality but draw attention to something; **errors**, however, must necessarily be corrected for the code to run.

Example of an error:

```{r, eval=FALSE}
((13+2+1,5)/3) + log(96, base = 4)
```

You might also forget to close a parenthesis, quotation mark, bracket, or brace; in these cases, R will wait for the command to close the code block, indicating with a `+`:

```{r, eval=FALSE}
((13+2+1.5)/3 + log(96, base = 4)
```

If this happens, go to the console and press ESC, which will end the block so you can correct it.

The commands `log` and `sqrt` are two of many basic functions that R has. Functions are organized sets of instructions to perform a task. For all of them, R has a description to help in their use. To access this help, use:

```{r, eval=FALSE}
?log
```

And the function description will open in RStudio's `Help` window.

If R's own description isn't enough for you to understand how the function works, search on Google (preferably in English). There are many websites and forums with educational information about R functions.

## Vector Operations

Vectors are the simplest structures worked with in R. We build a vector with a numeric sequence using:

```{r}
c(1,3,2,5,2)
```

**IMPORTANT NOTE**: The *c* is R's function (*Combine Values into a Vector or List*) with which we build a vector!

We use the `:` symbol to create sequences of integer numbers, like:

```{r}
1:10
```

We can use other functions to generate sequences, such as:

```{r}
seq(from=0, to=100, by=5)
# or
seq(0,100,5) # If you already know the order of the function arguments
```

* Create a sequence using the `seq` function that varies from 4 to 30, with intervals of 3.

```{r, echo=FALSE}
seq(from=4, to=30, by=3)
```

The `rep` function generates sequences with repeated numbers:

```{r}
rep(3:5, 2)
```

We can perform operations using these vectors:

```{r,eval=FALSE}
c(1,4,3,2)*2
c(4,2,1,5)+c(5,2,6,1)
c(4,2,1,5)*c(5,2,6,1)
```

Notice that it's already getting tiresome to type the same numbers repeatedly, let's solve this by creating **objects** to store our vectors and much more.

# Creating Objects

The storage of information in objects and their possible manipulation makes R an *object-oriented* language. To create an object, simply assign values to variables, as follows:

```{r, results='hide'}
x = c(30.1,30.4,40,30.2,30.6,40.1)
# or
x <- c(30.1,30.4,40,30.2,30.6,40.1)

y = c(0.26,0.3,0.36,0.24,0.27,0.35)
```

Old-school users tend to use the `<-` sign, but it has the same function as `=`. Some prefer to use `<-` for object assignment and `=` only for defining arguments within functions. Organize yourself in the way you prefer.

To access the values within the object, simply:

```{r}
x
```

The language is case-sensitive. Therefore, `x` is different from `X`:

```{r, eval=FALSE}
X
```

The object `X` was not created.

The naming of objects is a personal choice, but it's suggested to maintain a pattern for better organization. Here are some tips:

* Use descriptive names
* Avoid starting with numbers
* Don't use spaces (use _ or camelCase)
* Don't use special characters
* Maintain consistency in the chosen pattern
* Avoid very long names
* Don't use accents or non-ASCII characters

Some names cannot be used because they establish fixed roles in R:

* TRUE - True, logical value
* FALSE - False, logical value
* if, else, for, while, break, next - Reserved words for conditional and loop structures
* for, while, repeat - Reserved words for loop structures
* function - Reserved word for function definition
* in, NA, NaN, NULL - Reserved words for special values
* NA_integer__, NA_real_, NA_character_, NA_complex_ - Special values to represent missing data

We can then perform operations with the created object:

```{r}
x+2
x*2
```

To perform the operation, R aligns the two vectors and performs the operation element by element. Observe:

```{r}
x + y
x*y
```

If the vectors have different sizes, it will repeat the smaller one to perform the element-by-element operation with all elements of the larger one.

```{r, results='hide'}
x*2
x*c(1,2)
```

If the smaller vector is not a multiple of the larger one, we'll get a warning:

```{r}
x*c(1,2,3,4)
```

Notice that the **warning** doesn't compromise the code's functionality; it just gives a hint that something might not be as you'd like.

We can also store the operation in another object:

```{r, results='hide'}
z <- (x+y)/2
z
```

We can also apply some functions, for example:

```{r}
sum(z)  # sum of z values
mean(z) # mean
var(z)  # variance
```

## Indexing

We access only the 3rd value of the created vector with `[]`:

```{r, results='hide'}
z[3]
```

We can also access the numbers from position 2 to 4 with:

```{r}
z[2:4]
```

To get information about the created vector, use:

```{r}
str(z)
```

The `str` function tells us about the structure of the vector, which is a **numeric** vector with 6 elements.

Vectors can also receive other categories such as **characters**:

```{r}
clone <- c("GRA02", "URO01", "URO03", "GRA02", "GRA01", "URO01")
```

Another class is **factors**, which can be a bit complex to handle.

Generally, factors are values categorized by `levels`. For example, if we transform our character vector `clone` into a factor, levels will be assigned to each word:

```{r}
clone_factor <- as.factor(clone)
str(clone_factor)
levels(clone_factor)
```

This way, we'll have only 4 levels for a vector with 6 elements, since the words "GRA02" and "URO01" are repeated. We can get the number of elements in the vector or its length with:

```{r}
length(clone_factor)
```

There are also **logical** vectors, which receive true or false values:

```{r}
logical <- x > 40
logical   # Are the elements greater than 40?
```

With it we can, for example, identify which positions have elements greater than 40:

```{r}
which(logical)  # Getting the positions of TRUE elements

x[which(logical)] # Getting numbers greater than 40 from vector x by position
# or
x[which(x > 40)]
```

We can also locate specific elements with:

```{r}
clone %in% c("URO03", "GRA02")
```

The functions `any` and `all` can also be useful. Research about them.

Find more about other logical operators, like the `>` used, at this [link](http://www.statmethods.net/management/operators.html).

**Warning1**

Create a numeric sequence containing 10 integer values, and save it in an object called "a".

```{r}
(a <- 1:10)
```

Create another sequence, using decimal numbers and any mathematical operation, so that its values are identical to object "a".

```{r}
b <- seq(from = 0.1, to = 1, 0.1)
(b <- b*10)
```

The two vectors look equal, don't they?

Then, using a logical operator, let's verify if object "b" is equal to object "a".

```{r}
a==b
```

Some values are not equal. How is this possible?

```{r}
a==round(b)
```

**Warning2**

It's not possible to mix different classes within the same vector. When trying to do this, notice that R will try to equalize to a single class:

```{r}
wrong <- c(TRUE, "oops", 1)
wrong
```

In this case, all elements were transformed into characters.

**Some Tips**:

* Be careful with operation priority; when in doubt, always add parentheses according to your priority interest.
* Remember that if you forget to close any `(` or `[` or `"`, R's console will wait for you to close it, indicating with a `+`. Nothing will be processed until you directly type a `)` in the console or press ESC.
* Be careful not to overwrite already created objects by creating others with the same name. Use, for example: height1, height2.
* Keep in your .R script only the commands that worked and, preferably, add comments. You can, for example, comment on difficulties encountered, so you don't make the same mistakes later.

> If you're ahead of your colleagues, you can already do the exercises from [**Session 1**](exercises-Portugues.html#session1); if not, do them at another time and send us your questions.

## Matrices

Matrices are another class of objects widely used in R, with them we can perform large-scale operations in an automated way.

Since they are used in operations, we typically store numeric elements in them. To create a matrix, we determine a sequence of numbers and indicate the number of rows and columns in the matrix:

```{r}
X <- matrix(1:12, nrow = 6, ncol = 2)
X
```

We can also use sequences already stored in vectors to generate a matrix, as long as they are numeric:

```{r}
W <- matrix(c(x,y), nrow = 6, ncol =2)
W
```

With them we can perform matrix operations:

```{r}
X*2
X*X        
X%*%t(X)          # Matrix multiplication
```

Using these operations requires knowledge of matrix algebra. If you want to delve deeper into this, the book *Linear Models in Statistics, Rencher (2008)* has a good review about it. You can also explore R syntax for these operations at this [link](http://www.statmethods.net/advstats/matrix.html).

We access the numbers inside the matrix by giving the coordinates [row,column], as in the example:

```{r}
W[4,2] # Number positioned in row 4 and column 2
```

Sometimes it can be informative to give names to the columns and rows of the matrix, we do this with:

```{r}
colnames(W) <- c("height", "diameter")
rownames(W) <- clone
W
```

These functions `colnames` and `rownames` also work with data.frames.

## Data.frames

Unlike matrices, we don't perform operations with data.frames, but they allow the combination of vectors with different classes. Data frames are similar to tables generated in other programs, like Excel.

Data frames are combinations of vectors of the same length. All the ones we've created so far have size 6, verify this.

We can thus combine them into columns of a single data.frame:

```{r}
field1 <- data.frame("clone" = clone,     # Before the "=" sign  
                     "height" = x,        # we establish the names  
                     "diameter" = y,      # of the columns
                     "age" = rep(3:5, 2),
                     "cut"= logical) 
field1
```

We can access each of the columns with:

```{r}
field1$age
```

Or also with:

```{r}
field1[,4] 
```

Here, the number inside the brackets refers to the column, being the second element (separated by comma). The first element refers to the row. Since we left the first element empty, we're referring to all rows for that column.

This way, if we want to obtain specific content, we can give the coordinates with [row,column]:

```{r}
field1[1,2] 
```

* Get the diameter of clone "URO03".

```{r, echo=FALSE}
field1[3,3] 
```

Even though it's a data frame, we can perform operations with the numeric vectors it contains.

* With the diameter and height of the trees, calculate the volume according to the following formula and store it in a `volume` object:

$3.14*(diameter/2)^2*height$

```{r, echo=FALSE}
volume <- 3.14*((field1$diameter/2)^2)*field1$height
volume
```

Now, let's add the calculated vector with the volume to our data frame. For this, use the `cbind` function.

```{r}
field1 <- cbind(field1, volume)
field1
str(field1)
```

**Some tips**:

* Remember that, to build matrices and data frames, the columns must have the same number of elements.

* If you don't know which operator or function should be used, search on Google or ask chatgpt or any other tool. For example, if you're unsure how to calculate the standard deviation, search for "standard deviation R". The R community is very active and most of your questions about it have already been answered somewhere on the web.

* Don't forget that everything you do in R needs to be explicitly indicated, like a multiplication 4ac with `4*a*c`. To generate a vector 1,3,2,6 you need: `c(1,3,2,6)`.

## Lists

Lists consist of a collection of objects, not necessarily of the same class. In them, we can store all the other objects we've already seen and retrieve them through indexing with `[[`. As an example, let's use some objects that have already been generated.

```{r}
my_list <- list(field1 = field1, height_mean = tapply(field1$height, field1$age, mean), matrix_ex = W)
str(my_list)
```

I want to access the data.frame `field1`

```{r}
my_list[[1]] 
# or
my_list$field1
```

To access a specific column in the data.frame `field1`, which is inside my_list:  

```{r}
my_list[[1]][[3]]
# or
my_list[[1]]$diameter
# or
my_list$field1$diameter
```

Lists are very useful, for example, when we are going to use/generate various objects within a loop.

## Arrays

This is a type of object that you probably won't use at the beginning, but it's good to know about its existence. Arrays are used to store data with more than two dimensions. For example, if we create an array:

```{r}
(my_array <- array(1:24, dim = c(2,3,4)))
```

We will have four matrices with two rows and three columns, and the numbers from 1 to 24 will be distributed in them by columns.

> If you're ahead of your colleagues, you can already do the exercises from [**Session 2**](exercises-Portugues.html#session2); if not, do them at another time and send us your questions through the forum.

# Importing and Exporting Data

RData files are exclusive to R, clicking twice on the file or using:

```{r}
load("data/dia_1.RData")
```

You will recover all objects generated so far in the tutorial. To generate this RData file, I ran all the codes from here up and used:

```{r, eval=FALSE}
save.image(file = "dia_1.RData")
```

This command saves everything you have in your Global Environment (all objects that appear there in the top right corner). You can also save only one object with:

```{r, eval=FALSE}
save(field1, file = "field1.RData")
```

If we remove it from our Global Environment with:

```{r, eval=FALSE}
rm(field1)  # Make sure you saved the RData file before removing it
```

We can easily get it back with:

```{r, eval=FALSE}
load("field1.RData")
```

The RData format is exclusive to R, it's interesting to use it to do what we're doing - we stop the analysis one day, we'll continue on another and we don't want to have to run everything again. But often we need to export our data to other programs, which require other formats, such as `.txt` or `.csv`. For this we use:

```{r, eval=FALSE}
write.table(field1, file = "field1.txt", sep = ";", dec = ".", row.names = FALSE)
write.csv(field1, file = "field1.csv", row.names = TRUE)
```

Note: You can acquire packages to export and import data with other formats, for example the `xlsx` package exports and imports data with Excel format. The `vroom` package can be used to compress large tables. To install packages, use the function `install.packages("package_name")` and to load the package use `library(package_name)`. We'll see more about packages in the "Package Application" session of this course.

When exporting, there are several options for file formatting, it's important to consider them if the file will be used in another software later.

Open the generated files in your notepad to view their formatting. Notice that the `.txt` file was saved with the separator `;` and the decimal separator `.`. The `.csv` file was saved with the comma separator `,` and the decimal separator `.`.

These files can be read again by R, using the functions and their specifications:

```{r, eval=FALSE}
field1_txt <- read.table(file = "field1.txt", sep=";", dec=".", header = TRUE)
field1_csv <- read.csv(file = "field1.csv")
head(field1_txt)
head(field1_csv)
```

Now that we've learned how to import data, let's work with the dataset generated from the participants of the Marker Biometry course (ESALQ/USP - Brazil) - Class of 2021.

<span style="color:red">
The spreadsheet with the data is available in the link below, add it to your working directory or indicate the folder path when importing it into R, as follows. </span>

* [data.RData](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/dados_alunos2021.RData)
* [data.csv](https://cristianetaniguti.github.io/Workshop_genetica_esalq/CursoRBiometria_2021/dados_alunos2021.csv)

We can also import the data directly from GitHub by pointing to the web address.

```{r, eval=FALSE}
data <- read.csv("https://github.com/Cristianetaniguti/Workshop_genetica_esalq/raw/master/SIFSC11/dados_alunos2021.csv")
```

Here we'll also use the `na.strings` argument which will indicate how missing data were named.

```{r, eval=FALSE}
data <- read.csv(file = "dados_alunos2021.csv", na.strings="-", header = T, dec = ",")
head(data)
```

```{r}
load("data/dados_alunos2021.RData")
```

Let's explore the structure of the collected data:

```{r}
str(dados)
# also
dim(dados)
```

Notice that in the column names there are still the complete questions from the form, let's change them to names that are easier to work with:

```{r}
colnames(dados)

colnames(dados) = c("Occupation", "Graduation", "Genetics_Knowledge", "Statistics_Knowledge", "Gen_Stat_Knowledge", 
                   "Latitude", "Longitude")
colnames(dados)
str(dados)
```

# Manipulating Data

Now we'll use the data we have to learn different commands and functions in the R Environment.

First, let's check how many students answered the course form questions by counting the number of rows, using the `nrow` function.

```{r}
nrow(dados)
```

Let's then verify if we have people in our group who share the same graduation and occupation.

We can easily check this with the `table` function, which indicates the frequency of each observation:

```{r, eval=FALSE}
table(dados$Graduation)
table(dados$Occupation)
```

Note: The function `table` creates a frequency table showing how many times each unique value appears in the specified column.

# Conditional Structures

## if and else

For our next activity with the data, let's first understand how `if` and `else` structures work.

In conditional functions `if` and `else`, we establish a condition for if, if it's true the activity will be performed, otherwise (else) another task will be performed. As in the example:

```{r}
if(2 > 3){
  cat("two is greater than three")
} else {
  cat("two is not greater than three")
}
```

* Find out the Level of Knowledge in Genetics (3rd column) of the second person who responded (row 2). Send a motivational message if they have basic knowledge, another if the person already has Intermediate or Advanced knowledge (remaining responses). (hint: the `==` sign refers to "exactly equal to")

```{r}
if(dados[2,3] =="Basic"){
  cat("Keep going, Mendel believes in you!")
} else {
  cat("Mendel appreciates your preference")
}
```

We can specify more than one condition by repeating the `if` `else` structure:
Now let's study the occupation of the people who answered the questionnaire.

```{r}
if(dados[2,1] == "Masters"){
  cat("Hang in there, payday is coming!")
} else if (dados[2,1] == "PhD"){
  cat("Like your master's friends, believe the scholarship will be in by Friday!")
} else {
  cat("This one already has a steady job, how nice!")
}
```

But notice that it's only possible to use these structures for an individual element of the vector or for the entire vector; if we want to traverse the elements individually, we need to resort to another resource.

# Repetition Structures

## For

This resource can be the `for` function, a widely used and powerful function. It constitutes a loop structure, as it will apply the same activity repeatedly until reaching a certain condition. See examples:

```{r}
for(i in 1:10){
  print(i)
}

test <- vector()
for(i in 1:10){
  test[i] <- i+4 
}
test
```

In the cases above, `i` functions as an index that will vary from 1 to 10 in the operation determined between curly braces.

With this structure, we can repeat the operation performed with the `if` and `else` structures for the entire vector:

```{r, eval=F}
for(i in 1:nrow(dados)){
  if(dados[i,1] == "Masters"){
    print("Hang in there, payday is coming!")
  } else if (dados[i,1] == "PhD"){
    print("Like your master's friends, believe the scholarship will be in by Friday!")
  } else {
    print("This one already has a steady job, how nice!")
  }
}
```

**Tip: Indentation**

Notice the difference:

```{r, eval=FALSE}
# Without indentation
for(i in 1:nrow(dados)){
if(dados[i,1] == "Masters"){
print("Hang in there, payday is coming!")
} else if (dados[i,1] == "PhD"){
print("Like your master's friends, believe the scholarship will be in by Friday!")
} else {
print("This one already has a steady job, how nice!")
}
}

# With correct indentation
for(i in 1:nrow(dados)){
  if(dados[i,1] == "Masters"){
    print("Hang in there, payday is coming!")
  } else if (dados[i,1] == "PhD"){
    print("Like your master's friends, believe the scholarship will be in by Friday!")
  } else {
    print("This one already has a steady job, how nice!")
  }
}
```

The RStudio code editor has a feature to indent R code, select the area you want to indent and press `Ctrl+i`.

Now let's work with column 2, which contains the participants' graduation information. Notice that the `table` function returns different categories that could be summarized into just one, such as "Agricultural Engineering" and "Agronomy". Let's use a loop to find out which ones responded with areas related to "Agro". Then, which of these responses weren't "Agronomy" and ask this participant to modify the response by typing just "Agronomy".

Tip 1: To identify the "Agro" pattern we can use the `grepl` function.
Tip 2: We can use if within if

```{r}
# Example of using the grepl function
dados[,2]
grepl("Agro", dados[,2]) # Which lines contain the characters "Agro"
dados[grepl("Agro", dados[,2]),2]

for(i in 1:nrow(dados)){
  if(grepl("Agro", dados[i,2])){
    if(dados[i,2] != "Agronomy"){
     print("Please, replace your answer with Agronomy.") 
    }
  } 
}
```

To be able to print object content during the loop, we use the `cat` function, it doesn't separate each response into a line, we need to put `\n` indicating the line break.

Now let's homogenize this information ourselves. We can store the position of the identified lines in a variable, then we'll manually correct only those:

```{r}
homog <- vector()
for(i in 1:nrow(dados)){
  if(grepl("Agro", dados[i,2])){
    if(dados[i,2] != "Agronomy"){
     print("Please, replace your answer with Agronomy.") 
     homog <- c(homog, i)
    }
  } 
}

homog
```

> How would you correct these wrong elements? Try it!

['dados[homog, 2] <- "Agronomy"']{.spoiler}

## While

In this type of repetition structure, the task will be performed until a certain condition is met.

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  cat(x)
}
```

It's very important that in this structure the condition is met, otherwise the loop will run infinitely and you'll have to interrupt it by external means. An example of these "external means" in RStudio is clicking the red symbol in the top right corner of the console window. You can also press Ctrl+C in the console.

It's not very difficult for this to happen, just a small error like:

```{r, eval=FALSE}
x <- 1

while(x < 5){
  x + 1
  cat(x)
}
```

Here we can use the `break` and `next` commands to meet other conditions, like:

```{r}
x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) break
  cat(x)
}

x <- 1

while(x < 5){
  x <- x + 1
  if(x==4) next
  cat(x)
}

```

The `break` command stops the loop completely when the condition is met, while `next` skips the rest of the current iteration and continues with the next one.

## Repeat

This structure also requires a stop condition, but this condition is necessarily placed inside the code block using `break`. It then repeats the code block until the condition interrupts it.

```{r}
x <- 1
repeat{
  x <- x+1
  cat(x)
  if(x==4) break
}

```

The `repeat` structure is similar to `while`, but with the key difference that the stop condition must be explicitly defined within the code block using `break`. It will continue to execute the code block indefinitely until it encounters the `break` statement.

## Loops within Loops

It's also possible to use repetition structures within repetition structures. For example, if we want to work on both columns and rows of a matrix.

```{r}
# Creating an empty matrix
ex_mat <- matrix(nrow=10, ncol=10)

# each number inside the matrix will be the product of the column index by the row index
for(i in 1:dim(ex_mat)[1]) {
  for(j in 1:dim(ex_mat)[2]) {
    ex_mat[i,j] = i*j
  }
}

```

Another example of use:

```{r}
var1 <- c("fertilizer1", "fertilizer2")
var2 <- c("ESS", "URO", "GRA")

w <- 1
for(i in var1){
  for(j in var2){
    file_name <- paste0(i,"_plant_",j,".txt")
    file <- data.frame("block" = "fake_data", "treatment" ="fake_data")
    write.table(file, file = file_name)
    w <- w + 1
  }
}

# Check your working directory, files should have been generated
```

> If you're ahead of your colleagues, you can already do the exercises from [**Session 3**](exercises.html#session3), if not, do them at another time and send us your questions through the forum.

**Some tips**:

* Be careful when running the same command multiple times, some variables might not be the same as they were before. For the command to work the same way, the input objects need to be in the form you expect.
* Remember that `=` is for defining objects and `==` is the equality sign.
* In conditional and repetition structures, remember that it's necessary to maintain the expected syntax: If(){} and for(i in 1:10){}. In *for*, we can change the letter that will be the index, but it's always necessary to provide a sequence of integers or characters.
* Using indentation helps to visualize the beginning and end of each code structure and makes it easier to open and close braces. Indentation refers to those spaces we use before the line, like:

```{r}
# Creating an empty matrix
ex_mat <- matrix(nrow=10, ncol=10)

# each number inside the matrix will be the product of the column index by the row index
for(i in 1:dim(ex_mat)[1]) {   # First level, no space
  for(j in 1:dim(ex_mat)[2]) { # Second level has one space (tab)
    ex_mat[i,j] = i*j          # Third level has two spaces
  }                            # Closed the second level
}                              # Closed the first level

```

The consistent use of indentation makes your code more readable and helps prevent errors by making the structure clearer. Most modern IDEs, including RStudio, provide automatic indentation features to help maintain this consistency.

# Vectorization

Although loops are intuitive and easier to understand, they are slower and less efficient than vectorization. Vectorization is a technique that allows operations to be applied to all elements of a vector or matrix at once, without the need to iterate over each element individually.

Here is a simple example of non-vectorized code (using a loop) and its vectorized version:

```{r}
# Not vectorized (using loop)
numbers <- 1:5
loop_result <- numeric(length(numbers))
for(i in 1:length(numbers)) {
    loop_result[i] <- numbers[i] * 2
}

# Vectorized approach
numbers <- 1:5
vectorized_result <- numbers * 2

loop_result == vectorized_result
```

> This code transformation can become more complex depending on the scenario. For example, think about how a vectorized version of the previous loop would look like:

```{r}
# Not vectorized (using loop)
ex_mat <- matrix(nrow=10, ncol=10)

for(i in 1:dim(ex_mat)[1]) {   
  for(j in 1:dim(ex_mat)[2]) { 
    ex_mat[i,j] = i*j          
  }                            
}

# Vectorized?
```

This is a good moment for you to practice using an AI tool to help you transform the code into a vectorized version. You can use chatgpt or copilot, for example. Compare the result of the provided code with what you generated with the loop to verify if the tool is really doing what you want. This transformation is worth it if the loop code is taking too long or if you have to run the same code many times.

['ex_mat <- outer(1:10, 1:10, "*")']{.spoiler}


